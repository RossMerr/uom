package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/types"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"

	"github.com/RossMerr/uom/tools/ucum"
)



func main() {
	log.SetFlags(0)
	log.SetPrefix("prefix: ")

	// Parse the package once.
	dir := "."

	g := Generator{}

	// Print the header and package clause.
	g.Printf("// Code generated by \"uomprefix %s\"; DO NOT EDIT.\n", strings.Join(os.Args[1:], " "))
	g.Printf("\n")
	g.Printf("package uom")
	g.Printf("\n")

	doc := ucum.Import()
	g.generate(doc.Prefixs)

	// Format the output.
	src := g.format()

	// Write to file.
	outputName := filepath.Join(dir, "prefix.uom.go")

	err := ioutil.WriteFile(outputName, src, 0644)
	if err != nil {
		log.Fatalf("writing output: %s", err)
	}
}


// Generator holds the state of the analysis. Primarily used to buffer
// the output for format.Source.
type Generator struct {
	buf bytes.Buffer // Accumulated output.
	pkg *Package     // Package we are scanning.
}

type Package struct {
	name  string
	defs  map[*ast.Ident]types.Object
	files []*File
}

func (g *Generator) generate(ary []ucum.Prefix) {
	g.Printf("// Prefix the scalar value by which the unit atom is multiplied if combined with the prefix\n")
	g.Printf("type Prefix float64\n")

	g.Printf("const (\n")
	for _, p := range ary {
		g.Printf("%v Prefix = %v\n", strings.Title(p.Name), p.Value.Value)
	}
	g.Printf(")\n")
}


func (g *Generator) Printf(format string, args ...interface{}) {
	fmt.Fprintf(&g.buf, format, args...)
}

// format returns the gofmt-ed contents of the Generator's buffer.
func (g *Generator) format() []byte {
	src, err := format.Source(g.buf.Bytes())
	if err != nil {
		// Should never happen, but can arise when developing this code.
		// The user can compile the output to see the error.
		log.Printf("warning: internal error: invalid Go generated: %s", err)
		log.Printf("warning: compile the package to analyze the error")
		return g.buf.Bytes()
	}
	return src
}

// File holds a single parsed file and associated data.
type File struct {
	pkg  *Package  // Package to which this file belongs.
	file *ast.File // Parsed AST.
	// These fields are reset for each type being generated.
	typeName string  // Name of the constant type.
	values   []Value // Accumulator for constant values of that type.

	trimPrefix  string
	lineComment bool
}

// Value represents a declared constant.
type Value struct {
	originalName string // The name of the constant.
	name         string // The name with trimmed prefix.
	// The value is stored as a bit pattern alone. The boolean tells us
	// whether to interpret it as an int64 or a uint64; the only place
	// this matters is when sorting.
	// Much of the time the str field is all we need; it is printed
	// by Value.String.
	value  uint64 // Will be converted to int64 when needed.
	signed bool   // Whether the constant is a signed type.
	str    string // The string representation given by the "go/constant" package.
}
